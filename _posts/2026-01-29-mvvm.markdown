---
layout: post
title:  "MVVM Fundamentals"
date:   2026-01-29 00:00:00 +0000
tags: [iOS, Software Architecture Pattern]
author: Neoren
excerpt: "A comprehensive guide to MVVM for iOS development"
---
## History及简介

- **2005**年由微软提出（SwiftUI 2019年发布），引入SwiftUI后非常受欢迎、被广泛采用

- MVVM强调将应用的**视图**和**逻辑**相分离
- MVVM将代码分为**模型**、**视图**、**视图模型** 三部分
- 重要原则：View和Model之间不能直接通信，必须通过ViewModel作为中介
- 间接通信也实现了数据的**双向绑定**：模型的数据变化会反应到界面上，用户在界面上的操作也会通过ViewModel更新回模型数据

## MVVM架构中各层的职责和结构

### View层

- 职责：

  - 负责 **UI 展示 + 交互事件采集**

  - 只做**轻量逻辑**：布局、动画、简单的显示分支

  - 不直接访问网络/数据库/缓存，不写业务规则

- 结构：
  - 持有一个ViewModel实例（通过@Observable + @State/@Bindable）
  - 用$将输入绑定到vm的状态
  - 事件调用：vm.onAppear() (页面出现时加载数据), vm.refresh() (下拉刷新), vm.submit() (表单提交)
  - 事件调用里的逻辑应该是**业务编排** 

### ViewModel层

- 职责：

  - 提供View可直接消费的**状态**

  - 把**用户意图**转换成**动作**（对应View中的事件调用，比如：）

    <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260130002359714.png" alt="image-20260130002359714" style="zoom:50%;" />

  - 协调业务流程：（意图转换成动作时）调用 UseCase/Service/Repository (**业务编排**)，进行必要的数据转换、格式化、排序、过滤、权限判断等 (**适配/派生**)

    <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260129214614001.png" alt="image-20260129214614001" style="zoom:50%;" />

  - **管理异步**：Task {}、async/await，以及**错误处理、取消**（可选）

- 结构：

  - iOS 17+：_**@Observable**_ class XxxViewModel { ... }
  - 将 UI 状态集中成一个类型更清晰：_**enum ViewState**_ { case idle, loading, loaded([Item]), empty, failed(String) } 或 _**struct State**_ { var items: [Item]; var isLoading: Bool; ... }
  - 依赖通过初始化注入（便于测试）：init(service: FooServiceProtocol)
  - 经验法则：ViewModel 不持有 View（某属性不应指向一个View），也不返回 View（某方法不应返回一个View）；它**只输出“可渲染的数据 + 可调用的动作”**

### Model层

- <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260219153431318.png" alt="image-20260219153431318" style="zoom:50%;" />

- **领域模型**(Domain Model / Entity)职责：

  - 描述**业务数据结构与规则**（例如 User, Trip, Photo）
  - 可包含纯业务计算（不依赖 UI/网络）
  - 尽量保持与 UI 无关、与存储无关

- **数据来源与业务用例**职责：

  - **Repository**：屏蔽数据来源（网络/数据库/缓存），对上提供统一接口

    <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260219155049592.png" alt="image-20260219155049592" style="zoom:50%;" />
  - **Service/API Client**：封装网络请求细节
  - **UseCase**（可选）：把“业务动作”封装成可复用单元
  - 是否需要 UseCase 取决于项目规模：中大型项目更值得拆出来，小项目可以 VM 直接调用 Repository。

- 推荐链路：**ViewModel → UseCase → Repository → Domain Model → ViewModel(转UI State)**

- <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260218145451100.png" alt="image-20260218145451100" style="zoom:50%;" />

- <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260218145932961.png" alt="image-20260218145932961" style="zoom:50%;" />

### 小结

<img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260129232957932.png" alt="image-20260129232957932" style="zoom:50%;" />

## 数据流向

<img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260130001346508.png" alt="image-20260130001346508" style="zoom:50%;" />

## MVVM架构的优点

- 分离关注点后，代码的**可维护性提高**
- 由于ViewModel不依赖View，可以在不启动UI的情况下进行单元测试，这使**可测试性提高**
- 代码更干净，**可读性更好**
- **单一可信源**符合SwiftUI哲学

## PokedexUI（GitHub示例项目）

### README.md

- PokedexUI implements a **Protocol-Oriented MVVM** architecture with **Clean Architecture** principles (不是严格的Clean架构，因为没有Domain层). 

- 整洁架构的核心是：

  - 把代码按职责分层

    <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260130220421343.png" alt="image-20260130220421343" style="zoom:50%;" />

  - 让依赖方向保持干净可控

    <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260130220531574.png" alt="image-20260130220531574" style="zoom:50%;" />

  - 协议隔离细节

    <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260130231649521.png" alt="image-20260130231649521" style="zoom:50%;" />

### Cursor代码解读

- 项目结构图：<img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260224212837381.png" alt="image-20260224212837381" style="zoom:50%;" />

  <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260224212915405.png" alt="image-20260224212915405" style="zoom:50%;" />

- **RootView**用来包装**PokedexView**，它从环境中取出modelContext作为依赖让PokedexView持有**PokedexViewModel**(modelContext: modelContext)和**ItemListViewModel**(modelContext: modelContext)。这两个ViewModel之所以依赖modelContext，是因为它们持有@ModelActor actor **DataStorageReader**，它的初始化DataStorageReader(modelContainer: modelContext.container)需要modelContext.container (这里关键是_**属性宏@ModelActor**_，它会展开生成成员modelContainer、modelContext、和初始化器init(modelContainer:)等)

- PokedexView可视为TabView框架视图，分4个Tab视图（pokedexTab, itemsTab, favoritesTab, searchTab），这些视图分别包装了**PokedexContent**(viewModel: \$viewModel)（数据流绑定了PokedexView持有的PokedexViewModel实例）、**ItemListView**(viewModel: itemListViewModel)（传递了一个ItemListViewModel实例，会在ItemListView里面创建并持有@State的ViewModel实例）、**SearchView**(viewModel: **SearchViewModel**(pokemon: viewModel.pokemon), selectedTab: \$viewModel.selectedTab)（SearchView @State持有传入的利用PokedexViewModel.pokemon进行初始化的SearchViewModel实例，同时绑定了selectedTab）、以及**BookmarksView**()。包装的后三个视图引入了NavigationStack结构 + 修饰符.applyPokedexStyling(title:)，这可使导航栏以固定格式（颜色、标题及字体等）显示，视图背景显示暗灰。

- PokedexViewModel为PokedexView提供的内容包括：

  - 状态值：selectedTab, grid.icon
  - 异步方法调用：requestPokemon()

  PokedexViewModel为PokedexContent (PokedexView的子视图)提供的内容包括：

  - 数据：pokemon: [PokemonViewModel] （来源：requestPokemon()方法里包装的fetchDataFromStorageOrAPI()方法。_**PokedexViewModel实现了DataFetcher协议并确定了其关联类型**_，故可以调用**DataFetcher协议**的默认扩展方法fetchDataFromStorageOrAPI()，该方法编排调用了DataFetcher协议要求的各种获取数据的方法在PokedexViewModel中的实现）
  - 状态值：grid, isLoading

  PokedexViewModel为PokedexToolBar (PokedexContent的子视图)提供的内容包括：

  - 状态值：grid.otherIcon, grid.toggle()
  - 方法：sort(by:)

- ItemListViewModel为ItemListView提供的内容包括：

  - 数据：items: [ItemData]（来源：loadItems()方法里包装的fetchDataFromStorageOrAPI()方法。_**ItemListViewModel实现了DataFetcher协议并确定了其关联类型**_，故可以调用**DataFetcher协议**的默认扩展方法fetchDataFromStorageOrAPI()，该方法编排调用了DataFetcher协议要求的各种获取数据的方法在ItemListViewModel中的实现）
  - 状态值：isLoading
  - 异步方法调用：loadItems()

- 项目的核心是_**从API获取数据**_，获取pokemon: [PokemonViewModel]的具体流程为：

  - fetchDataFromStorageOrAPI()方法中调用的DataFetcher协议默认扩展方法 _**fetchDataFromAPI()**_ (入口)
  - fetchDataFromAPI()调用DataFetcher协议要求的异步方法 _**fetchAPIData()**_ 并一起包装了转化和存储
  - PokedexViewModel中的DataFetcher协议的实现中的方法fetchAPIData()，调用了_**pokemonService.requestPokemon()**_ 异步方法，其中pokemonService = PokemonService()
  - PokemonService().requestPokemon()方法调用了异步方法 _**service.requestData()**_ ，其中service: APIService<Config> = _**APIService<Config>(config: Config())**_，Config是遵循 _**ServiceConfiguration**_ 协议的PokemonService里的嵌套结构体
  - actor APIService<Config>(config: Config())里包含一个_**networkService**_: Network.Service = _**Network.Service.default**_ （注意这来自一个**第三方依赖包Networking**）和一个_**config**_: Config = _**Config()**_，于是service.requestData()方法的实现中就可以调用_**networkService.request(request, logResponse: false)**_ ，其中参数_**request =  config.createRequest()**_。这里的createRequest()返回_**PokemonRequest.pokemon**_（一个枚举成员），它提供_**Requestable**_协议要求的encoding, httpMethod, endpoint, parameters等计算属性。最后networkService.request(request, logResponse: false) 会返回response: APIResponse，它包装results: _**[APIItem]**_，APIItem: Decodable包含属性name和url。获取response后，对response.results里的每一个APIItem开启并发详情请求任务，调用config._**createDetailRequest(from: try result.url.asURL().lastPathComponent)**_ 及networkService.request(request, logResponse: false)来获取details: [Pokemon]，最后调用config.transformResponse(details)来获取service.requestData()的返回值[PokemonViewModel]

  获取items: [ItemData]的具体流程为：

  - fetchDataFromStorageOrAPI()方法中调用的DataFetcher协议默认扩展方法 _**fetchDataFromAPI()**_ (入口)
  - fetchDataFromAPI()调用DataFetcher协议要求的异步方法 _**fetchAPIData()**_ 并一起包装了转化和存储
  - ItemListViewModel中的DataFetcher协议的实现中的方法fetchAPIData()，调用了_**itemService.requestItems()**_ 异步方法，其中itemService = ItemService()
  - ItemService().requestItems()方法调用了异步方法 _**service.requestData()**_ ，其中service: APIService<Config> = _**APIService<Config>(config: Config())**_，Config是遵循 _**ServiceConfiguration**_ 协议的ItemService里的嵌套结构体
  - actor APIService<Config>(config: Config())里包含一个_**networkService**_: Network.Service = _**Network.Service.default**_ （注意这来自一个**第三方依赖包Networking**）和一个_**config**_: Config = _**Config()**_，于是service.requestData()方法的实现中就可以调用_**networkService.request(request, logResponse: false)**_ ，其中参数_**request =  config.createRequest()**_。这里的createRequest()返回_**ItemRequest.items(limit: Int)**_（一个枚举成员），它提供_**Requestable**_协议要求的encoding, httpMethod, endpoint, parameters等计算属性。最后networkService.request(request, logResponse: false) 会返回response: APIResponse，它包装results: _**[APIItem]**_，APIItem: Decodable包含属性name和url。获取response后，对response.results里的每一个APIItem开启并发详情请求任务，调用config._**createDetailRequest(from: try result.url.asURL().lastPathComponent)**_ 及networkService.request(request, logResponse: false)来获取details: [ItemDetail]，最后调用config.transformResponse(details)来获取service.requestData()的返回值[ItemData]，其中ItemData包装了title和items: [ItemDetail]

- 第一个Tab视图**pokedexTab**：

  - pokedexTab: some View作为PokedexView中的_**计算属性**_，返回视图**PokedexContent**(viewModel: \$viewModel)（数据流绑定了PokedexView持有的PokedexViewModel实例）
  - PokedexContent利用绑定的PokedexViewModel实例，包装了视图**PokedexGridView**(pokemon: viewModel.pokemon, grid: viewModel.grid, isLoading: viewModel.isLoading)，并在其上应用修饰符.applyPokedexStyling(title: Tabs.pokedex.title)将导航栏和背景设置成固定样式，再应用修饰符.toolbar { PokedexToolbar(viewModel: $viewModel) }在工具栏（也是导航栏）添加布局选择按钮和排序菜单
  - 注意这里绑定的PokedexViewModel实例的状态值如果发生变化，PokedexContent的body就要重新渲染，也就是PokedexGridView将重画
  - PokedexGridView用一个LazyVGrid包装所有**PokedexGridItem**(pokemon: PokemonViewModel, grid: GridLayout) 
  - PokedexGridItem视图包装了一个“label”视图: **AsyncSpriteView**(viewModel:showOverlay:)，并将其导航到**PokemonDetailView**(viewModel: **PokemonDetailViewModel**(pokemon: pokemon))。同时利用@Namespace引入了导航过渡的动画
  - AsyncSpriteView视图为了显示精灵图，需持有actor **SpriteLoader**和actor **ImageColorAnalyzer**，它们异步加载image和color
  - PokemonDetailView持有@State PokemonDetailViewModel，后者提供：
    - 数据：pokemon: PokemonViewModel
    - 状态值：isBookmarked, isFlipped, frontSprite, backSprite, color
    - 动作方法：updateBookmarkStatus(from bookmarks: [Pokemon]), loadSpritesAndColor(withSpriteLoader spriteLoader: SpriteLoader, imageColorAnalyzer: ImageColorAnalyzer) async, toggleBookmark(in context: ModelContext), playSound(with audioPlayer: AudioPlayer) async, flipSprite(hapticFeedback: UIImpactFeedbackGenerator), flipSpriteBack(hapticFeedback: UIImpactFeedbackGenerator)
  - PokemonDetailView从环境中注入的基础设施/跨层能力包括：haptic: **UIImpactFeedbackGenerator** (属于UIKit框架), imageColorAnalyzer: ImageColorAnalyzer, audioPlayer: **AudioPlayer**, spriteLoader: SpriteLoader
  - PokemonDetailView刚加载时会启动异步任务来调用vm.loadSpritesAndColor，同时在视图刚出现时调用vm.updateBookmarkStatus来更新bookmark，并附加了一层视图颜色背景（上红下灰）和导航栏名字-id标题
  - PokemonDetailView主体视图被分为两部分，由两个方法（**spriteSection()**，**contentSection()**）分别返回这两个视图。spriteSection()再分为精灵图spriteImage()和动作按钮actionButtons()。spriteImage()根据vm.isFlipped显示精灵正/反面图，并做动画翻转。actionButtons()横向排列playSoundButton(), bookmarkButton(), flipButton()。
  - playSoundButton()包装了一个Button，它的动作是异步调用vm.playSound(with: audioPlayer)，playSound方法先从PokemonViewModel.lastestCry获取cryURL，再异步调用audioPlayer.play(from: cryURL)，play方法首先将url字符串封装进URL(string: url)(失败则返回)，再将URL实例传入AVPlayerItem(url:)，再将AVPlayerItem实例传入player = **AVPlayer**(playerItem:)，最后调用player?.play()。这要import **AVFoundation**。这里注意用AVPlayer播放声音时，还要设置音频会话对象AVAudioSession（把会话类别设为 .playback：告诉系统“这个 App 主要是要播放音频”）并激活。
  - bookmarkButton()包装了一个Button，它的动作是调用vm.toggleBookmark(in: modelContext)，toggleBookmark方法先从PokemonDetailViewModel中取出id，利用id生成FetchDescriptor<Pokemon>实例，再由模型上下文取出对应的Pokemon模型，将其isBookmarked值更改、赋予PokemonDetailViewModel中的isBookmarked、并由上下文写回存储
  - flipButton()包装了一个Button，它的动作为空，图标上放置了一个拖拽手势，当用户拖拽（最小距离为0）时会触发vm.flipSprite(hapticFeedback: haptic)，结束拖拽时会触发vm.flipSpriteBack(hapticFeedback: haptic)。flipSprite/flipSpriteBack方法会把isFlipped设为true/false，并调用hapticFeedback.impactOccurred() 
  - contentSection()主要包含基础信息部分basicInfoSection()、统计数据部分statsSection()、和招式部分movesSection()。

- 第二个Tab视图itemsTab：

  - itemsTab: some View是PokedexView中的计算属性，它返回经导航栈包装后的视图**ItemListView**(viewModel: itemListViewModel)，ItemListView里经@State后持有**ItemListViewModel**实例
  - ItemListView视图用ScrollView包装**itemList**视图，同时在下载时显示进程图标动画，并启动任务调用异步方法vm.loadItems()来获取vm.items的[ItemData]值
  - itemList: some View是ItemListView中的计算属性，返回一个LazyVStack包装所有**itemRow**(for: item)。itemRow方法为每行建立导航链接**ItemDetailView**(viewModel: **ItemDetailViewModel**(item: item))
  - ItemDetailView用一个LazyVStack包装了所有**ItemDetailRowView**(item: item)

- 第三个Tab视图favoritesTab：

  - favoritesTab: some View是PokedexView中的计算属性，它用导航栈包装了**BookmarksView**()。BookmarksView首先查询得到所有isBookmarked = true的bookmarks: [Pokemon]，再将其映射成pokemonViewModels: [PokemonViewModel]，最后显示视图PokedexGridView(pokemon: pokemonViewModels, grid: .three)

- 第四个Tab视图searchTab：

  - searchTab: some View是PokedexView中的计算属性，它用导航栈包装了**SearchView**(viewModel: **SearchViewModel**(pokemon: viewModel.pokemon), selectedTab: $viewModel.selectedTab)
  - SearchView用@State持有一个SearchViewModel实例，并和PokedexViewModel.selectedTab绑定了selectedTab。SearchView显示一个PokedexGridView(pokemon: vm.filtered, grid: .three)，这里的filtered就是过滤后的[PokemonViewModel]，它的更新是由PokedexGridView的视图修饰符.onChange(of: viewModel.query) {_, _ in withAnimation(.bouncy) { viewModel.updateFilteredPokemon() } }产生的，它监听query字符串的变化，回调updateFilteredPokemon()

- 其它：

  - 需要参阅的文件：**SpriteLoader.swift**文件，缓存和网络下载精灵图
  - 你可以把 container 理解成：“当前这个 JSON 对象（大括号 {}）的读取手柄”。
  - KeyedDecodingContainer 就是“对某个 JSON 对象节点的按键读取接口”，支持继续深入嵌套解码
  - CodingKey协议的要求会由编码器自动生成，主要得到一个stringValue属性（比如.id.stringValue），会在解码时被间接调用
  - Keyed 是“字典/对象”，Unkeyed 是“数组/列表”

  - <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260204111043429.png" alt="image-20260204111043429" style="zoom:50%;" />

  - 解码中嵌套类/结构体就是嵌套字典

  - <img src="/Users/zhengjiancheng/Library/Application Support/typora-user-images/image-20260204132947030.png" alt="image-20260204132947030" style="zoom:30%;" />
  - 核心是把“怎么请求/怎么把响应变成 ViewModel”交给泛型 APIService 和 Config

  - PokemonService 是“业务入口”，APIService 是“通用引擎”

  - Config 负责告诉 APIService 三个点：列表请求怎么建、详情请求怎么建、最终怎么把详情数组变成 ViewModel 数组

  - @ModelActor 会为这个 actor 提供一个隔离的 SwiftData modelContext







